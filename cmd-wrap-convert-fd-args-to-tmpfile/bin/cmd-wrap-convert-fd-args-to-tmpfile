#!/usr/bin/env perl
# SPDX-License-Identifier: CC0-1.0
use strict;
use warnings;
use Getopt::Long;
use File::Temp qw(tempfile tempdir);
use File::Copy qw(copy);
use File::Spec;
use JSON::PP qw(encode_json);

# Parse command line options
Getopt::Long::Configure( qw(auto_help pass_through) );

my @suffixes;
my $dry_run;
GetOptions(
    "suffix=s" => \@suffixes,
    "dry-run"  => \$dry_run,
);

# remove option list terminator
shift @ARGV if @ARGV && $ARGV[0] eq '--';

# Read the original command from the arguments
my @original_command = @ARGV;

# Create a temporary directory
my $tempdir = $dry_run ? '[TEMP DIR]' : tempdir(CLEANUP => 1);

exit 1 unless @original_command;

# Function to convert /dev/fd/N to temporary files
sub convert_fd_to_tempfile {
    my ($fd, $suffix) = @_;

    (my $clean_name = $fd) =~ s/[^A-Za-z0-9\-\.]/_/g;
    # Create a temporary file in the temporary directory
    my $tempfile = File::Spec->catfile($tempdir, "fd_${clean_name}${suffix}");

    unless( $dry_run ) {
        open my $fh, '>', $tempfile or die "Failed to create temporary file $tempfile: $!";

        # Copy the contents of the FIFO to the temporary file
        copy($fd, $tempfile) or die "Failed to copy $fd to $tempfile: $!";
    }

    return $tempfile;
}

# Iterate over the command arguments and replace /dev/fd/N with temporary files
my @new_command;
my $suffix_index = 0;
foreach my $arg (@original_command) {
    if ($arg =~ m|^/dev/fd/\d+$| || -p $arg) {
        my $fd = $arg;
        my $suffix = $suffixes[$suffix_index] // '';
        push @new_command, convert_fd_to_tempfile($fd, $suffix);
        $suffix_index++ if $suffix_index < $#suffixes;
    } else {
        push @new_command, $arg;
    }
}

# Execute the new command and exit with its status
if( $dry_run ) {
    print encode_json({ command => \@new_command }), "\n";
} else {
    exit system(@new_command);
}
__END__

=pod

=head1 SYNOPSIS

cmd-wrap-convert-fd-args-to-tmpfile [options] command...

Options:

  --suffix

  --dry-run

=cut
