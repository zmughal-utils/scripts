#!/usr/bin/env perl
# SPDX-License-Identifier: CC0-1.0
use strict;
use warnings;
use Getopt::Long;
use File::Temp qw(tempfile tempdir);
use File::Copy qw(copy);
use File::Spec;
use JSON::PP qw(encode_json);

# Parse command line options
Getopt::Long::Configure( qw(auto_help pass_through) );

my @suffixes;
my $dry_run;
GetOptions(
	"suffix=s" => \@suffixes,
	"dry-run"  => \$dry_run,
);

# remove option list terminator
shift @ARGV if @ARGV && $ARGV[0] eq '--';

# Read the original command from the arguments
my @original_command = @ARGV;

# Create a temporary directory
my $tempdir = $dry_run ? '[TEMP DIR]' : tempdir(CLEANUP => 1);

exit 1 unless @original_command;

# Function to convert FIFO to temporary files
sub convert_fifo_to_tempfile {
	my ($fifo, $suffix) = @_;

	(my $clean_name = $fifo) =~ s/[^A-Za-z0-9\-\.]/_/g;
	# Create a temporary file in the temporary directory
	my $tempfile = File::Spec->catfile($tempdir, "fifo_${clean_name}${suffix}");

	unless( $dry_run ) {
		open my $fh, '>', $tempfile or die "Failed to create temporary file $tempfile: $!";

		# Copy the contents of the FIFO to the temporary file
		copy($fifo, $tempfile) or die "Failed to copy $fifo to $tempfile: $!";
	}

	return $tempfile;
}

# Iterate over the command arguments and replace FIFO with temporary files
my @new_command;
my $suffix_index = 0;
foreach my $arg (@original_command) {
	if (-p $arg) {
		my $fifo = $arg;
		my $suffix = $suffixes[$suffix_index] // '';
		push @new_command, convert_fifo_to_tempfile($fifo, $suffix);
		$suffix_index++ if $suffix_index < $#suffixes;
	} else {
		push @new_command, $arg;
	}
}

# Execute the new command and exit with its status
if( $dry_run ) {
	print encode_json({ command => \@new_command }), "\n";
} else {
	exit system(@new_command);
}
__END__

=pod

=head1 SYNOPSIS

cmd-wrap-convert-fifo-args-to-tmpfile [options] command...

Options:

  --suffix

  --dry-run

=cut
